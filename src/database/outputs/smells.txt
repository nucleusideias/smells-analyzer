[{"category":"Object-Orientation Abusers","name":"Switch Statements","description":"This smell occurs with the excessive use of switch statements (or long, complex chains of if-else-if) that make decisions based on the type of an object or some attribute that acts as a type code to determine the behavior to be executed. In object-oriented programming, using switch to simulate polymorphic behavior is often considered an anti-pattern. A common characteristic is that the logic of a single switch can be replicated or spread across different parts of the system. Consequently, adding a new condition (a new \"type\" or \"case\") requires finding and modifying all occurrences of these switch structures. This directly violates the Open/Closed Principle (OCP), which states that software entities should be open for extension but closed for modification.","java_example":"enum BirdType { EUROPEAN, AFRICAN, NORWEGIAN_BLUE } \n\nclass Bird { \n    private BirdType type;\n    // ... other attributes\n\n    double getSpeed() {\n        switch (type) {\n            case EUROPEAN:\n                return getBaseSpeed();\n            case AFRICAN:\n                return getBaseSpeed() - getLoadFactor() * getNumberOfCoconuts();\n            case NORWEGIAN_BLUE:\n                return (isNailed())? 0 : getBaseSpeed(voltage);\n        }\n        throw new RuntimeException(\"Should be unreachable\");\n    }\n}"},{"category":"Object-Orientation Abusers","name":"Temporary Field","description":"A Temporary Field is a class attribute (field) that only receives a value and is effectively used under certain circumstances or during the execution of a specific algorithm. Outside of these contexts, the field remains empty, null, or with an undefined value. The most common cause for creating temporary fields is an attempt to avoid very long parameter lists in a method that implements a complex algorithm. Instead of passing multiple values as parameters, the programmer chooses to store them as class fields. These fields are then used exclusively by this algorithm and remain idle (and often without valid initialization) during the rest of the object's lifecycle.","java_example":"public class Estimator {\n    private final Duration defaultEstimate;\n    // Temporary fields for the CalculateEstimate method\n    private List<Duration> durations;\n    private Duration average;\n    private Duration standardDeviation;\n\n    // ... constructor and other methods\n\n    public Duration CalculateEstimate(List<Duration> observedDurations) {\n        this.durations = observedDurations; // Temporary field receives value\n        calculateStats(); // Uses the temporary fields\n\n        if (this.durations == null || this.durations.isEmpty()) {\n            return this.defaultEstimate;\n        }\n        // Complex logic using this.average and this.standardDeviation\n        return this.average.plus(this.standardDeviation.multipliedBy(2)); // Example\n    }\n}"},{"category":"Object-Orientation Abusers","name":"Refused Bequest","description":"This smell occurs when a subclass inherits methods and properties from its superclass but deliberately does not use them, redefines them to do nothing (no-op), or redefines them in a way that violates the contract or intent of the superclass. This indicates that the inheritance hierarchy may be poorly designed or that the \"is a type of\" relationship does not fully hold. The main cause is often a misguided motivation to use inheritance: the desire to reuse code from a superclass, even when the conceptual relationship between superclass and subclass is weak or nonexistent.","java_example":"class Vehicle {\n    public void Drive() { System.out.println(\"Vehicle is driving.\"); }\n    // ... other methods\n}\n\nclass Plane extends Vehicle {\n    @Override\n    public void Drive() {\n        // A plane does not \"drive\" in the same sense.\n        throw new UnsupportedOperationException(\"Planes fly, they don't drive.\");\n    }\n\n    public void Fly() { System.out.println(\"Plane is flying.\"); }\n}"},{"category":"Object-Orientation Abusers","name":"Alternative Classes with Different Interfaces","description":"This smell occurs when two or more classes perform identical or very similar functions, but do so through methods with different names or with distinct signatures (parameters, return type). The most likely cause is a lack of communication or knowledge: a developer creates a class for a certain functionality without knowing that a class with a similar purpose already exists in the system, possibly created by another developer or in another part of the project.","java_example":"public class BinaryParser // Does not implement a common interface\n{\n    public void Open(string filePath) { /* Logic to open binary file */ }\n    public bool HasReachedEnd { get; /* Logic to check end of file */ }\n    public Person GetPerson() { /* Logic to read person from binary */ return new Person(); }\n    public void Close() { /* Logic to close binary file */ }\n}\n\npublic class XmlParser // Does not implement a common interface\n{\n    public XmlParser(string filePath) { /* Logic to open XML file in constructor */ }\n    public void StartParse() { /* Preparation to parse XML */ }\n    public Person GetNextPerson() { /* Logic to read person from XML, returns null at end */ return new Person(); }\n    public void FinishParse() { /* Finalization of XML parsing */ }\n}"}]