[{"category":"Object-Orientation Abusers","name":"Switch Statements","description":"This smell occurs with the excessive use of switch statements (or long, complex chains of if-else-if) that make decisions based on the type of an object or on some attribute that functions as a type code, to then determine the behavior to be executed. In object-oriented programming, the use of switch to simulate polymorphic behavior is often considered an anti-pattern. A common characteristic is that the logic of a single switch can be replicated or spread across different parts of the system. Consequently, adding a new condition (a new \"type\" or \"case\") requires finding and modifying all occurrences of these switch structures. This directly violates the Open/Closed Principle (OCP), which states that software entities should be open for extension, but closed for modification.","java_example":"enum BirdType { EUROPEAN, AFRICAN, NORWEGIAN_BLUE } \n\nclass Bird { \n    \nprivate BirdType type; \n    \n// ... other fields and methods ...\n    \ndouble getSpeed() { \n        \nswitch (type) { \n            \ncase EUROPEAN: \n                return getBaseSpeed(); \n            \ncase AFRICAN: \n                return getBaseSpeed() - getLoadFactor() * getNumberOfCoconuts(); \n            \ncase NORWEGIAN_BLUE: \n                return (isNailed())? 0 : getBaseSpeed(voltage); \n        } \n        \nthrow new RuntimeException(\"Should be unreachable\"); \n    } \n}"},{"category":"Object-Orientation Abusers","name":"Temporary Field","description":"A Temporary Field is a class attribute (field) that only receives a value and is effectively used under certain circumstances or during the execution of a specific algorithm. Outside of these contexts, the field remains empty, null, or with an undefined value. The most common cause for the creation of temporary fields is the attempt to avoid very long parameter lists in a method that implements a complex algorithm. Instead of passing multiple values as parameters, the programmer chooses to store them as class fields. These fields are then used exclusively by this algorithm and remain idle (and often without valid initialization) during the rest of the object's life cycle.","java_example":"public class Estimator { \n    \nprivate final Duration defaultEstimate; \n    \n// Temporary fields for the CalculateEstimate method\n    \nprivate List<Duration> durations; \n    \nprivate Duration average; \n    \nprivate Duration standardDeviation; \n    \n// ... constructor and other methods ...\n\n        public Duration CalculateEstimate(List<Duration> observedDurations) { \n            this.durations = observedDurations; // Temporary field receives value\n            calculateStats(); // Uses the temporary fields\n            // ... complex logic using this.average and this.standardDeviation ...\n        } \n}"},{"category":"Object-Orientation Abusers","name":"Refused Bequest","description":"This smell occurs when a subclass inherits methods and properties from its superclass, but deliberately does not use them, redefines them to do nothing (no-op), or redefines them in a way that violates the contract or intent of the superclass. This indicates that the inheritance hierarchy may be poorly designed or that the \"is a type of\" relationship does not fully hold. The main cause is often a misguided motivation to use inheritance: the desire to reuse code from a superclass, even when the conceptual relationship between superclass and subclass is weak or non-existent.","java_example":"class Vehicle { \n    public void Drive() { System.out.println(\"Vehicle is driving.\"); } \n} \n\nclass Plane extends Vehicle { \n    @Override \n    public void Drive() { \n        // A plane does not \"drive\" in the same sense.\n        throw new UnsupportedOperationException(\"Planes fly, they don't drive.\"); \n    } \n    // ... other methods specific to Plane ...\n}"},{"category":"Object-Orientation Abusers","name":"Alternative Classes with Different Interfaces","description":"This smell occurs when two or more classes perform identical or very similar functions, but do so through methods with different names or with distinct signatures (parameters, return type). The most likely cause is a lack of communication or knowledge: a developer creates a class for a certain functionality without knowing that a class with a similar purpose already exists in the system, possibly created by another developer or in another part of the project. This leads to duplication of functionality under different \"disguises\" (interfaces).","java_example":"public class Person { /*... */ } \n\npublic class BinaryParser // Does not implement a common interface\n{ \n    public void Open(string filePath) { /* Logic to open binary file */ } \n    public Person GetPerson() { /* Logic to read person from binary */ return new Person(); } \n    // ... other methods ...\n} \n\npublic class XmlParser // Does not implement a common interface\n{ \n    public XmlParser(string filePath) { /* Logic to open XML file in constructor */ } \n    public Person GetNextPerson() { /* Logic to read person from XML */ return new Person(); } \n    // ... other methods ...\n}"}]