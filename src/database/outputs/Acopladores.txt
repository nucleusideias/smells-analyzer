[{"category":"Acopladores","name":"Inveja de Funcionalidades (Feature Envy)","description":"Um método exibe Feature Envy quando acede aos dados ou métodos de outra classe com mais frequência do que aos seus próprios. O método parece \"invejar\" as funcionalidades da outra classe e pode estar no local errado dentro da estrutura do código. Este smell ocorre frequentemente após os dados serem movidos para uma classe de dados, mas as operações sobre esses dados são deixadas para trás. Pode também surgir de um mal-entendido sobre onde a responsabilidade deve residir. Os problemas incluem a violação do encapsulamento, o aumento do acoplamento entre classes, a redução da coesão da classe de origem e a complicação dos testes. É um indicador de um design de classe pobre.","java_example":"class OrderPrinter {\n    public void printOrderShippingLabel(Order order) {\n        Customer customer = order.getCustomer();\n        Address custAddress = customer.getAddress();\n\n        String label = customer.getName() + \n                       \"\\n\" +\n                       custAddress.getStreet() +\n                       \"\\n\" +\n                       custAddress.getCity() +\n                       \", \" + custAddress.getZipCode();\n        System.out.println(label);\n    }\n}"},{"category":"Acopladores","name":"Intimidade Inapropriada (Inappropriate Intimacy)","description":"Este smell ocorre quando uma classe utiliza excessivamente os campos ou métodos internos de outra classe, ou quando duas classes estão fortemente acopladas através de comunicação bidirecional. Boas classes devem saber o mínimo possível umas sobre as outras para facilitar a manutenção e reutilização. O termo \"Negociação Interna\" (Insider Trading) é por vezes usado como sinónimo. Pode surgir de uma falta de limites claros ou de responsabilidades bem definidas entre as classes. Também pode ser um efeito colateral da tentativa de partilhar dados ou funcionalidades de forma demasiado direta. Os problemas incluem alto acoplamento, tornando o sistema frágil (alterações numa classe podem facilmente quebrar a outra), difícil de manter e mais complicado para reutilizar componentes independentemente.","java_example":"class OrderService {\n    // ...\n    public int calculateLateOrders() {\n        List<Order> orders = orderRepository.getAllOrders();\n        int lateOrders = 0;\n        for (Order order : orders) {\n            if (order.getDeliveryDate().before(new Date())) {\n                lateOrders++;\n            }\n        }\n        return lateOrders;\n    }\n\n    public void processOrder(Order order) {\n        // ...\n        order.processed = true; // Ou usando um setter de baixo nível\n        // ...\n    }\n}"},{"category":"Acopladores","name":"Cadeias de Mensagens (Message Chains)","description":"Uma Cadeia de Mensagens ocorre quando o código envolve uma sequência de chamadas como objetoA.getObjetoB().getObjetoC().fazerAlgumaCoisa(). O cliente solicita um objeto, que por sua vez solicita outro, e assim por diante. Isso frequentemente viola a Lei de Deméter (Princípio do Menor Conhecimento), que afirma que um objeto deve chamar apenas métodos dos seus \"amigos\" diretos. Podem surgir da exposição excessiva de estruturas internas de objetos. O código do cliente torna-se dependente do caminho de navegação ao longo da estrutura de classes. Os problemas incluem tornar o código frágil; qualquer alteração nas relações intermediárias da cadeia exige a modificação do cliente. Acopla fortemente o cliente à estrutura interna de múltiplos objetos e torna o código difícil de ler, entender e manter.","java_example":"class MasterControl {\n    // ...\n    public void disableSaving() {\n        this.getModelisable().getDockablePanel().getCustomizer().getSaveItem().setEnabled(false);\n    }\n}"},{"category":"Acopladores","name":"Homem do Meio (Middle Man)","description":"Uma classe Middle Man é aquela onde a maioria dos seus métodos simplesmente delega chamadas para métodos em outra classe. Se uma classe realiza apenas uma ação – delegar – a sua existência é questionável. Pode ser o resultado de uma aplicação excessivamente zelosa de Esconder Delegado ao remover Cadeias de Mensagens. Pode também ocorrer se o trabalho útil de uma classe for gradualmente movido para outras classes, deixando uma \"casca vazia\". Os problemas incluem a adição de complexidade desnecessária e uma camada extra de indireção, aumentando o tamanho do código sem adicionar valor significativo. Pode ser cansativo se cada nova funcionalidade no delegado exigir um novo método de delegação no servidor.","java_example":"class Manager {\n    private RealWorker worker = new RealWorker();\n\n    public void assignTask() {\n        worker.performTask(); // Simplesmente delega para RealWorker\n    }\n}"}]