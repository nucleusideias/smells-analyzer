[{"category":"Dispensables","name":"Comments","description":"This smell occurs when a method, class, or block of code is filled with explanatory comments that are, in fact, redundant, obsolete, misleading, or that try to justify confusing code that should be refactored to be self-explanatory. Symptoms and Causes: Comments are often created with the best intentions, usually when the code's author realizes that their logic is not immediately obvious or intuitive. However, in these cases, comments can act as a \"deodorant\" that masks the \"bad smell\" of code that needs structural improvements. Ideally, the code itself should be clear enough, and the best comment is often a well-chosen name for a method, variable, or class. Other symptoms include commented-out blocks of code (which should be in a version control system) and comments that merely paraphrase what a line of code already says obviously.","java_example":"// Excessively commented method\npublic double CalculateTriangleArea(double base, double height) {\n    // Calculate the area of the triangle using the formula: Area = (1/2) * base * height\n    return 0.5 * base * height;\n}"},{"category":"Dispensables","name":"Duplicate Code","description":"This is one of the most common and harmful code smells. It occurs when the same code fragment, or very similar fragments, appear in more than one place in the codebase. Symptoms and Causes: Duplication can arise when multiple programmers work on different parts of the same system without proper communication, resulting in the re-implementation of similar logic. Deadline pressure can lead to the practice of copying and pasting existing code that is \"almost\" what is needed, with minor modifications, instead of creating a reusable abstraction. In some cases, it may simply be the result of carelessness or laziness. Duplication is not always an exact copy; it can be subtle, with variations in variable naming or slight differences in logic, making it harder to detect.","java_example":"// Before refactoring\nint totalApplesPrice = quantityApples * priceApple - 5;\nint totalBananasPrice = quantityBananas * priceBanana - 5;\n\n// After refactoring\npublic static class PriceCalculator {\n    private const int Discount = 5;\n    public static int CalculatePriceWithDiscount(int quantity, int itemPrice) {\n        return quantity * itemPrice - Discount;\n    }\n}\nint totalApplesPrice = PriceCalculator.CalculatePriceWithDiscount(quantityApples, priceApple);\nint totalBananasPrice = PriceCalculator.CalculatePriceWithDiscount(quantityBananas, priceBanana);"},{"category":"Dispensables","name":"Data Class","description":"A Data Class is a class that primarily has fields (attributes) and trivial methods to access them (getters and setters), but lacks significant behavior or functionality of its own. These classes essentially act as passive containers of data, with other classes taking responsibility for manipulating that data. Symptoms and Causes: It is common for newly created classes to start with just a few public fields or properties with getters/setters. The smell arises when the class remains in this state, and the logic that operates on its data resides in other classes.","java_example":"// Before refactoring\npublic class CustomerData {\n    public String name;\n    public String email;\n    public String address;\n    // Getters and Setters for all fields\n}\n\npublic class CustomerService {\n    public boolean isValidCustomer(CustomerData customer) { ... }\n    public String getMailingLabel(CustomerData customer) { ... }\n}\n\n// After refactoring\npublic class Customer {\n    private String name;\n    private String email;\n    private String address;\n\n    // Constructor, Getters and Setters\n\n    public boolean isValid() { ... }\n    public String getMailingLabel() { ... }\n}\n\npublic class CustomerServiceRefactored {\n    public void processCustomer(Customer customer) { ... }\n}"},{"category":"Dispensables","name":"Dead Code","description":"Dead Code refers to variables, parameters, fields, methods, or entire classes that are no longer used or reachable within the program. This includes code snippets in complex conditionals that are never executed due to conditions that always evaluate the same way or logic errors. Common symptoms include code segments that no test coverage tool can reach, variables declared and initialized but never read, or private methods that are not called by any other method in the same class.","java_example":"// Before refactoring\npublic class ReportGenerator {\n    private String reportType; // Unused field\n    ...\n}\n\n// After refactoring\npublic class ReportGenerator {\n    // reportType removed\n    ...\n}"},{"category":"Dispensables","name":"Lazy Class","description":"A Lazy Class is one that performs so little useful functionality that it does not justify its own existence as a separate entity in the system. Maintaining and understanding classes always incurs costs in time and resources; therefore, a class should \"pay its way\" with the functionality it offers. Often, these classes demonstrate a \"distinct lack of diversity\" or insufficient behavior.","java_example":"// Before refactoring\nclass BasicAddressFormatter {\n    public String formatAddress(String street, String city, String zip) { ... }\n}\n\nclass Customer {\n    private BasicAddressFormatter formatter = new BasicAddressFormatter();\n    ...\n}\n\n// After refactoring\nclass Customer {\n    // BasicAddressFormatter is removed\n    ...\n    public String getFormattedAddress() { ... }\n    ...\n}"},{"category":"Dispensables","name":"Speculative Generality","description":"This smell occurs when the code includes \"hooks\" (hooks), special cases, classes, methods, or parameters created to anticipate future needs that have not materialized and may never materialize. It is the act of building something \"just in case\", which represents a direct violation of the YAGNI (\"You Ain't Gonna Need It\") principle.","java_example":"// Before refactoring\nabstract class DataExporter {\n    protected abstract void connectToDataSource();\n    ...\n}\nclass SimpleStringExporter extends DataExporter { ... }\n\n// After refactoring\ninterface MinimalDataExporter { \n    String exportData(Object data);\n}\nclass SimpleStringExporter implements MinimalDataExporter { ... }\n\n"}]