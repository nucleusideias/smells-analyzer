[{"category":"Change Preventers","name":"Divergent Change","description":"Occurs when a single class is frequently changed in different ways and for different, unrelated reasons. It is the opposite of the Shotgun Surgery smell, where a single conceptual change affects multiple classes. Symptoms include needing to modify multiple unrelated methods within the same class whenever a new requirement arises or an external change occurs. This violates the Single Responsibility Principle (SRP). Identifying Divergent Change can sometimes be aided by analyzing the version control system's change history.  If a specific class is consistently changed in commits that describe modifications to conceptually distinct functionalities, this is a strong indicator of the smell.","java_example":"// Before Refactoring (Patient class with multiple responsibilities):\n\npublic class Patient {\n    public String FirstName;\n    public String LastName;\n    public List<String> TreatmentHistory;\n\n    public Patient(String firstName, String lastName) {\n        this.FirstName = firstName;\n        this.LastName = lastName;\n        this.TreatmentHistory = new ArrayList<>();\n    }\n\n    public void addTreatment(String treatment) {\n        this.TreatmentHistory.add(treatment);\n    }\n\n    // Responsibility 1: Manage patient data (above)\n    // Responsibility 2: Export treatment history (below)\n    public String exportTreatmentHistoryToCSV() {\n        StringBuilder csvBuilder = new StringBuilder();\n        csvBuilder.append(\"TreatmentDate,Description,Doctor\\n\");\n\n        for (String treatment : this.TreatmentHistory) {\n            csvBuilder.append(treatment).append(\"\\n\");\n        }\n        return csvBuilder.toString();\n    }\n\n    // If we need to export to JSON, we add another method here, modifying the class for a new reason.\n    // If we need to add InsuranceNumber, we modify the class for another reason.\n}\n\n// After Refactoring (Extracting export responsibility):\n\npublic class PatientRefactored {\n    public String FirstName;\n    public String LastName;\n    public String InsuranceNumber; // New patient information\n    public List<String> TreatmentHistory;\n\n    public PatientRefactored(String firstName, String lastName, String insuranceNumber) {\n        this.FirstName = firstName;\n        this.LastName = lastName;\n        this.InsuranceNumber = insuranceNumber;\n        this.TreatmentHistory = new ArrayList<>();\n    }\n\n    public void addTreatment(String treatment) {\n        this.TreatmentHistory.add(treatment);\n    }\n}\n\ninterface TreatmentHistoryExporter {\n    String export(List<String> treatments);\n}\n\nclass CSVTreatmentHistoryExporter implements TreatmentHistoryExporter {\n    @Override\n    public String export(List<String> treatments) {\n        StringBuilder csvBuilder = new StringBuilder();\n        csvBuilder.append(\"TreatmentDate,Description,Doctor\\n\");\n        for (String treatment : treatments) {\n            csvBuilder.append(treatment).append(\"\\n\");\n        }\n        return csvBuilder.toString();\n    }\n}\n\nclass JSONTreatmentHistoryExporter implements TreatmentHistoryExporter {\n    @Override\n    public String export(List<String> treatments) {\n        // Logic to convert treatments to JSON format\n        return \"{\\\"treatments\\\":[]}\"; // Simplified example\n    }\n}"},{"category":"Change Preventers","name":"Shotgun Surgery","description":"Opposite of Divergent Change, Shotgun Surgery occurs when a single conceptual change in functionality requires applying many small changes to multiple different classes simultaneously. The root cause is often a lack of proper abstraction and duplication of common logic spread across multiple classes (copy-pasted code). It can also result from excessive violation of the Single Responsibility Principle, where a single responsibility has been unnecessarily fragmented into many small classes, or from excessive coupling between classes. This smell often results from violating the DRY (Don't Repeat Yourself) principle. Logic that should be centralized and reused ends up scattered, and any modification to this logic requires finding and changing all its copies. Long Message Chains can also lead to Shotgun Surgery, as a change in any link in the chain can propagate the need for changes in client code and other links in the chain.","java_example":"// Before Refactoring (Duplicated validation logic)\npublic class SavingsAccount {\n    private double balance;\n    private static final double MINIMUM_BALANCE_THRESHOLD = 1000;\n\n    public SavingsAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void withdraw(double amount) {\n        if (this.balance - amount < MINIMUM_BALANCE_THRESHOLD) {\n            throw new IllegalArgumentException(\"Withdrawal would bring balance below threshold!\");\n        }\n        this.balance -= amount;\n    }\n\n    public void transfer(double amount, SavingsAccount otherAccount) {\n        if (this.balance - amount < MINIMUM_BALANCE_THRESHOLD) {\n            throw new IllegalArgumentException(\"Transfer would bring balance below threshold!\");\n        }\n        this.balance -= amount;\n        otherAccount.deposit(amount);\n    }\n\n    public void deposit(double amount) {\n        this.balance += amount;\n    }\n}\n\n// After Refactoring (Extracting validateTransaction method)\npublic class SavingsAccountRefactored {\n    private double balance;\n    private static final double MINIMUM_BALANCE_THRESHOLD = 1000;\n\n    public SavingsAccountRefactored(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    private void validateTransaction(double amountToDebit) {\n        if (this.balance - amountToDebit < MINIMUM_BALANCE_THRESHOLD) {\n            throw new IllegalArgumentException(\"Transaction would bring balance below threshold!\");\n        }\n    }\n\n    public void withdraw(double amount) {\n        validateTransaction(amount);\n        this.balance -= amount;\n    }\n\n    public void transfer(double amount, SavingsAccountRefactored otherAccount) {\n        validateTransaction(amount);\n        this.balance -= amount;\n        otherAccount.deposit(amount);\n    }\n\n    public void deposit(double amount) {\n        this.balance += amount;\n    }\n}"},{"category":"Change Preventers","name":"Parallel Inheritance Hierarchies","description":"This smell occurs when, for each subclass created in one inheritance hierarchy, a corresponding subclass must be created in another inheritance hierarchy. The two (or more) hierarchies evolve in parallel, mirroring each other. A common symptom is a common prefix or suffix in the class names in both hierarchies (e.g., Vehicle and VehicleView, with subclasses Car/CarView, Truck/TruckView). The fundamental problem is that this duplicated structure requires any addition or modification in one hierarchy to be reflected in the other, increasing maintenance effort and the risk of inconsistencies. This indicates strong structural coupling and a form of conceptual duplication, where the variation logic is replicated in multiple inheritance trees. The need to keep these hierarchies synchronized manually is error-prone.","java_example":"// Before Refactoring (Parallel Inheritance Hierarchies)\nabstract class Shape { abstract void draw(); }\nclass Circle extends Shape { @Override void draw() { /* draw circle */ } }\nclass Square extends Shape { @Override void draw() { /* draw square */ } }\n\nabstract class ShapeRenderer { abstract void render(Shape s); }\nclass CircleRenderer extends ShapeRenderer { @Override void render(Shape s) { if (s instanceof Circle) { /* render circle */ } } }\nclass SquareRenderer extends ShapeRenderer { @Override void render(Shape s) { if (s instanceof Square) { /* render square */ } } }\n\n// After Refactoring (Moving render responsibility to Shape)\nabstract class ShapeRefactored {\n    abstract void renderSelf();\n}\nclass CircleRefactored extends ShapeRefactored {\n    @Override void renderSelf() { System.out.println(\"Rendering Circle\"); }\n}\nclass SquareRefactored extends ShapeRefactored {\n    @Override void renderSelf() { System.out.println(\"Rendering Square\"); }\n}"}]