[{"category":"Bloaters","name":"Long Method","description":"A method is considered long when it contains an excessive number of lines of code. A common heuristic suggests that methods with more than 10 to 15 lines should be examined more closely. The main consequence is that the longer a method, the more difficult it becomes to understand and maintain it. Frequent causes include adding new functionalities to existing methods instead of creating new ones, and the need for comments within the method body to explain different sections. Long methods often violate the Single Responsibility Principle (SRP).","java_example":"// Before Refactoring\npublic class OrderPrinter {\n    public void printOrderDetails(Order order) {\n        // Print header\n        System.out.println(\"OrderId: \" + order.id);\n        System.out.println(\"Order Date: \" + order.orderDate);\n\n        // Print order items\n        System.out.println(\"Items:\");\n        for (String item : order.items) {\n            System.out.println(\"- \" + item);\n        }\n\n        // Print billing address\n        System.out.println(\"Billing Address: \" + order.billingAddress);\n\n        // Print shipping address\n        System.out.println(\"Shipping Address: \" + order.shippingAddress);\n\n        // Print total\n        System.out.println(\"Total: $\" + order.total);\n    }\n}\n\n// After Refactoring\npublic class OrderPrinterRefactored {\n    public void printOrderDetails(Order order) {\n        printHeader(order);\n        printOrderItems(order);\n        printBillingAddress(order);\n        printShippingAddress(order);\n        printTotal(order);\n    }\n\n    private void printHeader(Order order) { /* ... */ }\n    private void printOrderItems(Order order) { /* ... */ }\n    private void printBillingAddress(Order order) { /* ... */ }\n    private void printShippingAddress(Order order) { /* ... */ }\n    private void printTotal(Order order) { /* ... */ }\n}"},{"category":"Bloaters","name":"Large Class","description":"A Large Class, or God Class, accumulates an excessive number of fields, methods, or lines of code. More importantly, it violates the Single Responsibility Principle (SRP) by assuming many responsibilities that should be distributed among smaller, more cohesive classes.  Large classes often start small and grow over time as developers add functionalities to existing classes instead of creating new ones. A God Class centralizes a disproportionate amount of business logic or data coordination, becoming a central point of dependency and complexity.","java_example":"// Before Refactoring\npublic class User {\n    private String email;\n    private String firstName;\n    // ... other fields for address and profile\n\n    public User(String email, String firstName, /* ... other parameters */) { /* ... */ }\n\n    // Methods related to address\n    public String getFullAddress() { /* ... */ }\n    public void updateAddress(/* ... */) { /* ... */ }\n\n    // Methods related to profile\n    public String getProfileSummary() { /* ... */ }\n    public void updateBio(String bio) { /* ... */ }\n}\n\n// After Refactoring\nclass Address { /* ... */ }\nclass Profile { /* ... */ }\n\npublic class UserRefactored {\n    private String email;\n    private String firstName;\n    private Address address;\n    private Profile profile;\n\n    public UserRefactored(String email, String firstName, Address address, Profile profile) { /* ... */ }\n\n    // Getters and setters for email, firstName, address, and profile\n}"},{"category":"Bloaters","name":"Primitive Obsession","description":"This smell occurs when primitive data types (like integers, strings, booleans, simple arrays) are excessively used to represent domain concepts that would be better encapsulated by small dedicated objects or classes. The main cause is the apparent simplicity of adding a new primitive field instead of designing a new class. Symptoms include using multiple primitive variables that together represent a single concept (e.g., day, month, year for a date), using constants to encode type or state information (e.g., ORDER_STATUS_PENDING = 1), or using strings as field names in data arrays. A direct consequence is the lack of encapsulation and the scattering of validation and manipulation logic for these \"simulated types\" throughout the code.","java_example":"// Examples\nString zipCode = \"90210\"; // Instead of a ZipCode class\nString userName = \"john_doe\"; // Instead of a UserName class\ndouble money = 100.0; // Instead of a Money class"},{"category":"Bloaters","name":"Long Parameter List","description":"A method or constructor has a long parameter list when it receives an excessive number of arguments. More than three or four parameters usually indicate a possible smell. Long parameter lists can arise from merging multiple algorithms into a single method or from attempting to reduce coupling between classes by passing all necessary dependencies as parameters.  A long parameter list is often a symptom of unidentified Data Clumps being passed as individual arguments. Testing methods with long parameter lists is more complex.","java_example":"// Before Refactoring\npublic class Order {\n    public Order(String customerName, String customerAddress, /* ... other parameters */) { /* ... */ }\n}\n\n// After Refactoring\npublic class Customer { /* ... */ }\n\npublic class OrderRefactored {\n    public OrderRefactored(Customer customer, int orderNumber, /* ... other parameters */) { /* ... */ }\n}"},{"category":"Bloaters","name":"Data Clumps","description":"Data Clumps are groups of variables (fields, method parameters) that frequently appear together in different parts of the code.  The presence of these clumps suggests they should be encapsulated in their own class or structure. The main cause is often poor program structure or copy-paste programming. A good test to identify a Data Clump is to check if, when removing one of the values from the group, the others lose part of their contextual meaning. Refactoring Data Clumps to a new class risks creating a Data Class if the associated behavior isn't moved along with the data.","java_example":"// Before Refactoring\npublic class OldSystem {\n    public static void welcomeNew(String firstName, String lastName, int age, /* ... other parameters */) { /* ... */ }\n}\n\n// After Refactoring\nclass Person { /* ... */ }\n\npublic class NewSystem {\n    public static void main(String args) {\n        Person joe = new Person(\"John\", \"Doe\", 30, /* ... other parameters */);\n        joe.welcomeNew();\n    }\n}"}]